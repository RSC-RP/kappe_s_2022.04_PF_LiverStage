---
title: "CVG and Translocome Gene Expression"
author: "Jenny L Smith"
date: "`r Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10)

options(stringsAsFactors = FALSE, max.print = 100)
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{r message = FALSE, warning=FALSE}
library(tidyr)
library(tibble)
library(magrittr)
library(dplyr)
library(stringr)
library(ggplot2)
library(gridExtra)
library(ggpubr)
library(patchwork)
library(limma)
library(edgeR)
library(SummarizedExperiment)
library(patchwork)
library(maSigPro)
library(svglite)
suppressPackageStartupMessages(library(mclust))
```

```{r}
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("select","dplyr")
conflicted::conflict_prefer("arrange","dplyr")
conflicted::conflict_prefer("mutate","dplyr")
```

Note about fonts:

```{r}
#https://www.tidyverse.org/blog/2021/02/svglite-2-0-0/
system_fonts = list(sans = "Open Sans")
systemfonts::system_fonts()
```


# Define Functions 

```{r}
#from https://github.com/mikelove/DESeq2/blob/master/R/plots.R
#Want to return the whole scores matrix so can examine 3d pca plots. 
plotPCA.DESeq.mod <- function(object, intgroup="condition", ntop=500, returnData=FALSE, PC3=FALSE)
{
  library(matrixStats)
  # calculate the variance for each gene
  rv <- rowVars(assay(object))
  
  # select the ntop genes by variance
  select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  
  # perform a PCA on the data in assay(x) for the selected genes
  pca <- prcomp(t(assay(object)[select,]))
  
  # the contribution to the total variance for each component
  percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
  
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  
  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop=FALSE])
  
  # add the intgroup factors together to create a new grouping factor
  group <- if (length(intgroup) > 1) {
    factor(apply( intgroup.df, 1, paste, collapse=":"))
  } else {
    colData(object)[[intgroup]]
  }
  
  # assembly the data for the plot - first 10 PCs
  # d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], group=group, intgroup.df, name=colnames(object))
  n <- min(10, ncol(as.data.frame(pca$x)))
  d <- data.frame(as.data.frame(pca$x)[,1:n], group=group, intgroup.df, name=colnames(object))
  
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:10]
    rot <- pca$rotation[,1:10] #for first 10 PCs
    dat <- list("scores"=d,"rotation"=rot)
    return(dat)
  }
}

#Updated on 6/9/17 to use variance stabilized transformed data as input (not center scaled log2, like in princomp)
PCA <- function(expnData,phenovector,
                title="",round=TRUE,colorCodes=NULL,
                ntop=500, GOI=NULL){
  
  suppressPackageStartupMessages(library(DESeq2))
  library(ggplot2)
  #expnData is the raw counts (not normalized) has patient IDs as colnames and genes as rownames. 
  
  samples <- intersect(names(phenovector), colnames(expnData))
  countData <- expnData[,samples]
  phenovector <- phenovector[samples]
  colData <- as.data.frame(phenovector)
  
  if(round){
    countData <- round(countData, digits = 0)
  }
  
  #Create as DESeq data set object (dds)
  dds <- DESeqDataSetFromMatrix(countData = countData,
                                  colData = colData,
                                  design = ~ 1)
  
  #perform variance stabilized transformation 
  dds <- dds[ rowSums(counts(dds)) > 10, ]
  varianceStab <- vst(dds, blind = TRUE)
  
  #if given a list of genes of interest
  if (! is.null(GOI)){
    GOI <- intersect(GOI, rownames(assay(varianceStab)))
  }else{
    GOI <- 1:nrow(varianceStab)
  }
  
  #PCA data frame with the wieghts/loadings and eigen vectors
  pca.dat <- plotPCA.DESeq.mod(varianceStab[GOI,], 
                               intgroup = "phenovector", 
                               ntop = ntop,
                               returnData=TRUE)
  
  plots <- lapply(c(2:3), function(pc){
      percentVar <- attr(pca.dat$scores, which="percentVar")
      y_var <- paste0("PC",pc)
      
      p <- ggplot(data=pca.dat$scores, 
             aes_string(x="PC1", y=y_var, color="phenovector")) + 
        geom_point(size=3, alpha=0.75) +
        xlab(paste0("PC1: ",round(percentVar[1] * 100),"% variance")) +
        ylab(paste0(y_var,": ",round(percentVar[pc] * 100),"% variance")) +
        labs(title=title) +
        theme_classic() +
        theme(legend.position = "top")
      if(!is.null(colorCodes)){
        p <- p + 
          scale_color_manual(values=colorCodes)
      }
      return(p)
  })
  
  #Final Results object
  res <- list(dds, varianceStab,pca.dat, plots)
  names(res) <- c("dds", "vst","pca_data","pca_plots")
  
  if(is.character(GOI)){
    res[["GOI"]] <- GOI
  }
  
  return(res)
}
```

```{r}
#changed on 2/14/18, see bottom of Heatmaps_Function.r for the original one used.
dge_dendrograms <- function(expnData, pheno, method,
                            genelist=NULL,add.count=1, percent=0.05,
                            ntop=500,filterTopGenes=FALSE, createDGE=TRUE,log=FALSE){
  #df with count data, patient IDs are column names and rows are genes.
  #pheno is a character vector with patient IDs as names, and the status for each in each group (eg pos,neg)
  #genelist is a character vector with the genes of interest
  #percent is the % of samples in the input expn matrix that must express a gene at 1 CPM. Filter to remove low count genes.
  #set log=TRUE if providing a log2 expression dataframe.
  #filterTopGenes shuold be a logical. If TRUE filter top 1000 most varied genes.
  suppressPackageStartupMessages(require(edgeR))
  suppressPackageStartupMessages(library(dendextend))
  suppressPackageStartupMessages(library(matrixStats))

  expnData <- expnData[, intersect(names(pheno), colnames(expnData))] #ensure correct order, drop rows with nas just in case
  if(createDGE){
    dge <- DGEList(counts = expnData)
    #keep the rows (genes) with at least 1 CPM in a minimum of 2 samples or X% of samples. 
    keep.dge <- rowSums(cpm(dge) >= 1) >= max(2,(percent*ncol(expnData))) 
    # subset for those genes with cmp >= 1 per gene in samples
    dge <- dge[keep.dge,] #
    dge <- calcNormFactors(dge)
    TMMCPM <- cpm(dge, normalized.lib.sizes = TRUE,
                  log = TRUE, prior.count = add.count)

  }else{
    TMMCPM <- as.matrix(expnData)
    if(!log){
      TMMCPM <- log2(expnData+add.count) #log2 transform counts
    }
  }

  if(is.null(genelist) & filterTopGenes){
      # calculate the variance for each gene
      rv <- rowVars(as.matrix(TMMCPM))
      # select the ntop genes by variance
      select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
      #select the top 1000 most varied genes
      TMMCPM <- TMMCPM[select,]
  }else if(!is.null(genelist)){
    TMMCPM <- TMMCPM[which(rownames(TMMCPM) %in% genelist), ] #subset the matrix to genes of interest
  }


  d1 <- dist(t(TMMCPM), method = "euclidean", diag = FALSE,
             upper = FALSE) #sample distances WITHOUT SCALING
  d2 <- dist(TMMCPM, method = "euclidean", diag = FALSE,
             upper = TRUE) #gene distances WITHOUT SCaling
  samp.c1 <- hclust(d1, method = method, members = NULL) #sample clustering
  gene.c2 <- hclust(d2, method = method, members = NULL) #gene clustering
  list <- list(TMMCPM,samp.c1,gene.c2)
  names(list) <- c("TMMCPM","samp.c1", "gene.c2")

  return(list)
}

```


```{r}
#Pheatmap
quickPheatmap <- function(expn,geneList, sample_data,
                          gene_index=NULL,
                          annots_col_colors=NULL){
  library(pheatmap)

  len <- 299
  col <- colorRampPalette(c("deepskyblue4", "deepskyblue3", "deepskyblue2", "deepskyblue1","white","red1", "red2", "red3", "red4"))(n=len)

  e <- expn[geneList, intersect(colnames(expn), rownames(sample_data))]
  sample_data <- sample_data[intersect(colnames(expn), rownames(sample_data)), ]
  anno.col <- sample_data
  #if scaling, this doesnt work. would need to scale the expression matrix myself
  # Breaks <- c(seq(min(e), 0, length.out=ceiling(len/2) + 1),
  #             seq(max(e)/len, max(e), length.out=floor(len/2)))
 
  if(is.null(annots_col_colors)){
    annots_col_colors <- lapply(anno.col, function(column){
        grps <- unique(column)
        n <- length(grps)
        pal <- RColorBrewer::brewer.pal(n,name="Set1")
        names(pal) <- grps
        return(pal)
      })
  }


  p <- pheatmap::pheatmap(mat= e ,
                     color=col,
                     border_color="black",
                     scale = "row", 
                     cluster_rows=FALSE,
                     cluster_cols=TRUE,
                     clustering_method="ward.D2",
                     clustering_distance_cols="correlation",
                     annotation_names_col=TRUE,
                     annotation_col = anno.col,
                     annotation_colors = annots_col_colors,
                     gaps_row=gene_index,
                     show_rownames=TRUE,
                     fontsize_row=5,
                     fontsize_col = 10,
                     # kmeans_k=9,
                     show_colnames=TRUE)


  return(p)

}
```

```{r}
create_annots_hmap <- function(expn, pheno_df, cols,
                               goi=NULL,cc=NULL, 
                               colorbar.height=5){
  #expn is the normalized expression values with genes as rownames
  #gene list a character vector
  #goi are genes of interest to highlight on the Heatmap. Character vector of gene symbols
  #cc are color codes in WHICH FORMAT?
  #cols is a character vector of column names

  #Example on how to use the reuslts:
  #hmap <- ComplexHmap(XXXX, hmap_anno_obj=res$annoColumn, XXX)
  # draw(hmap + res$geneLabels, heatmap_legend_side="right", annotation_legend_side="right")

    library(dplyr)
    suppressPackageStartupMessages(library(ComplexHeatmap))

    #subset the expression matix and the phenotype dataframe
    anno <- pheno_df %>%
      dplyr::filter(rownames(.) %in% colnames(expn)) %>% 
      rownames_to_column("id") %>% 
      dplyr::select(id, all_of(cols)) %>%
      mutate(id = factor(id, levels = colnames(expn))) %>%
      arrange(id) %>%  #ensure same order as the expn matrix
      column_to_rownames("id")
  
    #if no color codes provided, create one for each column
    if(is.null(cc)){
      pals <- c("npg", "aaas", "lancet", "jco", 
                    "ucscgb", "uchicago", "simpsons",
                    "rickandmorty")
      #if there are more columns than color palettes, just repeat the set of available color palettes
      if(length(ncol(anno)) > length(pals)){
        pals <- rep(pals,  ceiling(ncol(anno)/length(pals)))
      }
      #define unique colors for each column
      cc <- purrr::map(1:ncol(anno), function(i){
          grps <- unique(anno[[i]])
          ggpubr::get_palette(pals[i], k=length(grps)) %>% 
            magrittr::set_names(grps)
      })
      names(cc) <- colnames(anno)
    }
    
    #legend graphical parameters
    n <- max(sapply(cc, length))
    nrow <- ifelse(n <= 6, n, 6)
    ncol <- ceiling(n/nrow)
    params <- list(show_legend=TRUE,
                  labels_gp= gpar(fontsize=12),
                  title_gp= gpar(fontsize=16),
                  nrow = nrow,
                  ncol=ncol,
                  by_row=TRUE)
    
    #Create the complex heatmap annotation column
    annoCol <- suppressWarnings(HeatmapAnnotation(df = dplyr::select(anno, all_of(cols)),
                                   name="Main Groups",
                                   col=cc,
                                   which="column",
                                   gap=unit(1,"mm"),
                                   border = T,
                                   show_annotation_name = TRUE,
                                   annotation_name_gp=gpar(fontsize=12),
                                   annotation_name_offset=unit(1,"mm"),
                                   annotation_name_side="left",
                                   annotation_height=unit(colorbar.height, "cm"),
                                   annotation_legend_param = params,
                                   simple_anno_size_adjust=TRUE))
    res <- list("annoColumn"=annoCol)
    if(!is.null(goi)){
      regex <- paste0("^",goi,"$", collapse = "|")
      goi.idx <- grep(regex, rownames(expn))
      labels <- rownames(expn)[goi.idx] #needs to be numeric indexes for complexheatmap
      #create the row (gene) labels object
      labs <- circlize::rowAnnotation(link = anno_mark(at=goi.idx,
                                             labels=labels,
                                             which="row",
                                             link_width=unit(1, "mm")),
                            width= unit(1, "mm") + max_text_width(labels),
                            gp=gpar(fontsize=4))

      res[["geneLabels"]] <-  labs
    }
    return(res)
}


complex_hmap <- function(mat,
                        hmap_anno_obj,
                        hmap_anno_obj_genes=NULL,
                        name="z-scores",
                        scale=TRUE,
                        space.type="sRGB",
                        color_palette=NULL,
                        split=NULL, 
                        cluster.method="ward.D2",
                        show_sample_ids=FALSE,
                        dge_dendrograms.res=NULL,
                        samp_dend_order=NULL){
  #mat is the normalized, log2 (usually) transformed counts
  #name is the title
  #scale is whether to scale by row
  #color palette is a colorRamp2() object.
  #threshold is whether to make all z-scores in a certain range.
  #hmap_anno_obj is from HeatmapAnnotation() function
  #space.type is for the color/shades on the heatmap. See ?Heatmap for all the choices.
  #dge_dendrograms.res is the list object output from the dge_dendrograms() function.
  #samp_dend_order is the numeric vector or character vector of column names from the matrix (mat) or the dge_dengrograms.res$TMMCPM matix, in the desired order.

  suppressPackageStartupMessages(library(ComplexHeatmap))
  suppressPackageStartupMessages(require(circlize))
  library(RColorBrewer)
  suppressPackageStartupMessages(library(dendextend))
  ht_opt$message = FALSE

   if(scale){
      mat <- t(scale(t(mat))) ##rowwise scaling
   }
  
  print(range(mat))
  min <- round(min(mat))
  max <- round(max(mat))
  mid <- round(max/2, digits = 2)
    
  if(is.null(color_palette)){
    pal <- colorRamp2(c(min,-mid, 0, mid, max),
                      c("deepskyblue3", "deepskyblue","white", "red", "red3"),
                      space=space.type)
  }else{
    pal <- color_palette
  }
  # col <- colorRampPalette(c("cyan1", "cyan2", "cyan3", "cyan4","azure4","magenta4", "magenta3", "magenta2", "magenta1"))(n=299)
  #colorRamp2(c(-2, 0, 4), c("deepskyblue","white", "red"), space="RGB") #use for breaks.
  # colorPal <- colorRampPalette(c("deepskyblue4", "deepskyblue3", "deepskyblue2", "deepskyblue1","white","red1", "red2", "red3", "red4"))(n=299)

  #legend graphical parameters
  params <-  list(color_bar="continuous",
       legend_direction="horizontal",
       title_position="topcenter",
       legend_width=unit(5,"cm"),
       legend_height=unit(5,"cm"),
       title_gp=gpar(fontsize=10,
                     fontface="bold"),
      at = c(min,-mid, 0,mid, max),
      just = c("left", "top"))
  
    if(!is.null(dge_dendrograms.res)){
        if(is.null(samp_dend_order)){
          clust <- dendextend::rotate(as.dendrogram(dge_dendrograms.res$samp.c1),
                           order=c(ncol(mat):1))
        }else{
          clust <- dendextend::rotate(as.dendrogram(dge_dendrograms.res$samp.c1),
                                  order=samp_dend_order)
      }
    }else{
      clust=TRUE
    }

    #create the heatmap plot
    hmap <- Heatmap(mat,
                    name=name,
                    col=pal,

                    heatmap_legend_param=params,
                    row_title="Genes",
                    row_title_side="left",
                    row_title_gp=gpar(fontsize=15,
                                      fontface="bold"),
                    show_row_names=FALSE,
                    show_column_names=show_sample_ids,
                    row_names_gp=gpar(fontsize=3),

                    column_title="Samples",
                    column_title_side="bottom",
                    column_title_gp=gpar(fontsize=15,
                                         fontface="bold"),
                    column_title_rot=0,
                    row_dend_width=unit(8,"mm"),
                    column_dend_height=unit(22.5,"mm"),

                    top_annotation=hmap_anno_obj,
                    right_annotation = hmap_anno_obj_genes,
                    split=split,
                    row_gap = unit(5, "mm"),

                    clustering_distance_rows="euclidean",
                    clustering_method_rows=cluster.method,
                    clustering_method_columns = cluster.method,
                    cluster_columns = clust,
                    column_dend_reorder=FALSE)

  return(hmap)
}
```

```{r}
create_pf_heatmaps <- function(TMMCPM,sample_annots, gene_annots,
                               center_scale=TRUE,
                               ntop=1000,order_ids=NULL,
                               genelist=NULL,
                               split=NULL,
                               heatmap_colors=NULL){
  pf_genes <- gene_annots %>% 
    as.data.frame() %>% 
    dplyr::filter(genome=="PF3D7") %>% 
    pull(gene_id)
  
  TMMCPM_all_pf <- TMMCPM[rownames(TMMCPM) %in% pf_genes, ]
  dends <- dge_dendrograms(expnData = TMMCPM_all_pf, 
                           pheno = pull(sample_annots, analysis_factor_group, name = masigpro_id), 
                           method = "ward.D2",
                           genelist = genelist, 
                           ntop=ntop,
                           log=FALSE,
                           filterTopGenes = TRUE,
                           createDGE = FALSE)
  
  # dim(dends$TMMCPM)
  hmap_anno_obj <- create_annots_hmap(expn=dends$TMMCPM,
                                      pheno_df = sample_annots,
                                      cc=NULL,
                                      colorbar.height=2,
                                      cols = c("analysis_factor_group"))
  
  name <- ifelse(center_scale, "z-scores","log2_CPM")
  res <- complex_hmap(mat=dends$TMMCPM, 
               scale=center_scale,
               name=name,
               hmap_anno_obj = hmap_anno_obj$annoColumn,
               dge_dendrograms.res = dends,
               samp_dend_order=order_ids,
               color_palette=heatmap_colors,
               split=split,
               show_sample_ids=TRUE)
  
  return(list("dends"=dends,"heatmap"=res))
  
}
```



# Sample Manifest and Expression Data

```{r}
pf_samples <- read.csv("samples/Kappe_s_2022.04_PF_LiverStage_ParasitesPaper_sample_manifest_7.25.2022.csv") %>% 
  set_rownames(.$sample_id_cat)

dim(pf_samples)
table(pf_samples$analysis_group)
```

```{r}
cb_se <- readRDS("expression_data/kappe_s_PfHsMmu_cated_Pf_ParasitesPaper_samples_Pf3D7v58_combat-seq_SummarizedExperiment.RDS")

cb_se
```

```{r}
cb_eset <- readRDS("expression_data/kappe_s_PfHsMmu_cated_Pf_ParasitesPaper_samples_Pf3D7v58_combat-seq_expressionSet.RDS")

# cb_eset
```

# Search for Non-canonical PEXEL 

```{r}
pexel_motifs <- data.frame(type=c("Canonical", rep("non-canonical",5)),
                           motif=c("R.L.E/D/Q","R.I.E/D/Q","K.L.E/D/Q",
                                   "H.L.E/D/Q","H.I.E/D/Q","A.L.E/D/Q"))

pexel_motifs
# write.csv(pexel_motifs, "pexel_motifs.csv", row.names = FALSE)
```

```{r}
nc_pexel_motifs <- tabulizer::extract_tables("references/PEXEL/mmi13024_supplemental_table2.pdf")

head(pexel_motifs)
class(pexel_motifs)

pexel_motifs[[2]] %>% head()
pexel_motifs[[1]] %>% as.data.frame()
```

```{r}
nc_pexel_motifs_clean <- purrr::map(pexel_motifs, function(x){
  df <- as.data.frame(x) 
  df %>%
    rename_all(~c("gene_id","description","motif")) %>%
    mutate(type="non-canonical")
}) %>% 
  bind_rows()
```

```{r}
nc_pexel_motifs_clean %>% 
  filter(gene_id != "") %>% 
  pull(gene_id) %>% 
  unique() %>%
  length() #388 
```

# Reference Data

```{r}
apicoplast_genes <- read.delim("expression_data/gene_annots/PF3D7_Apicoplast_GenesBySubcellularLocalization_Summary.txt", sep="\t") %>% 
  janitor::clean_names()

head(apicoplast_genes)
dim(apicoplast_genes) #506
```

WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by RJavaTools to method java.util.ArrayList$Itr.hasNext()
WARNING: Please consider reporting this to the maintainers of RJavaTools
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release

```{r}
apicoTP <- tabulizer::extract_tables("references/PEXEL/pone.0036598.s009.pdf") %>% 
  lapply(., as.data.frame) %>% 
  bind_rows() %>% 
  set_colnames(., value=.[1,]) %>%
  janitor::clean_names() %>% 
  filter(!grepl("Gene", gene_id1)) %>% 
  pivot_longer(cols = everything(),
               names_to = "type",
               values_to = "value") %>%
  filter(!grepl("description", type)) %>% 
  mutate(type=gsub("[12]$","", type)) %>% 
  pivot_wider(names_from = type,
              values_from = value) %>% 
  unnest()

dim(apicoTP)
# write.csv(apicoTP, "apicoTP_old_ids.csv", row.names = FALSE)
```

```{r}
apicoTP_update <- read.csv("expression_data/gene_annots/apicoTP_GeneByLocusTag_Summary.csv") %>% 
  janitor::clean_names() %>% 
  select(-source_id) %>% 
  distinct()

head(apicoTP_update)
dim(apicoTP_update) #535   8
# table(duplicated(apicoTP_update$gene_id))

unique(c(apicoplast_genes$gene_id, apicoTP_update$gene_id)) %>% length() #757
```


Pexel genes: 
 R at position 1, any charge-neutral amino acid at position 2, L at position 3, any charge-neutral amino acid at position 4, and E, D, or Q at position 5 (R.L.E/D/Q),
 
PlasmoDB search: 
 Pattern	RXLX[EQD]
Organism	Plasmodium falciparum 3D7

```{r}
pexel_genes <- read.delim("expression_data/gene_annots/PEXEL_canonical_motif_TranscriptRecordClass_Summary.txt") %>% 
  janitor::clean_names()

head(pexel_genes)
dim(pexel_genes) #1,437   11
```

```{r}
mito_genes <- rowData(cb_se) %>% 
  as.data.frame() %>% 
  filter(seqnames == "Pf3D7_MIT_v3" | grepl("mitochondrial", description, ignore.case = TRUE))

dim(mito_genes)
length(unique(mito_genes$gene_name))

table(rowData(cb_se)$seqnames) 
```

```{r}
apicoplast_ids <- unique(c(apicoplast_genes$gene_id, apicoTP_update$gene_id))

TM_domains <- read.delim("expression_data/gene_annots/P33D7_transmembrane_signal_peptides_Summary.txt", sep = "\t") %>% 
  janitor::clean_names() %>% 
  filter(!gene_id %in% mito_genes$gene_id) %>% 
  mutate_at(vars(signal_p_peptide,x_tm_domains), ~gsub("N/A",NA, .)) %>% 
  mutate(has_signal_peptide=!is.na(signal_p_peptide),
         has_tm_domain=case_when(
           x_tm_domains > 0 ~ TRUE,
           TRUE ~ FALSE
         ),
         apicoplast_protein=gene_id %in% apicoplast_ids,
         pexel_protein=gene_id %in% pexel_genes$gene_id) %>% 
  distinct() %>% 
  select(gene_id,source_id,
         matches("peptide|tm.domain"),
         apicoplast_protein,
         everything())

head(TM_domains)
dim(TM_domains) #5720   14
```

```{r}
table(TM_domains$has_signal_peptide)
table(TM_domains$has_tm_domain)
table(TM_domains$apicoplast_protein)
# table(duplicated(TM_domains$gene_id))
table(TM_domains$pexel_protein)
```


# Venn Diagram

```{r}
library(ggVennDiagram)
```

```{r}
cols <- c("has_signal_peptide","has_tm_domain","apicoplast_protein")
gene_lists <- lapply(cols, function(col){
  idx <- TM_domains[[col]]
  TM_domains$gene_id[idx]
})
names(gene_lists) <- cols

# gene_lists
```

```{r fig.height=7, fig.width=7}
# svglite::svglite("figures/tm_signal_apicoplast_venn.svg", height = 10, width = 10, fix_text_size=FALSE, system_fonts = list(sans = "Open Sans"))
ggVennDiagram(gene_lists,
              label_alpha=0.2,
              label_geom = "label",
              set_size=6, 
              label_size=6) + 
  scale_color_manual(values=c(viridis::viridis(n = 3))) +
  scale_fill_gradient(low="aliceblue", high = "deepskyblue3", 
                      name="Number of Genes")
  # theme(axis.text = element_text(size=4))
# dev.off()
```

# Expression Plots 

