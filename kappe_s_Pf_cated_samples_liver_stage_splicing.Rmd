---
title: "alternative splicing"
author: "Jenny L Smith"
date: "`r Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10)

options(stringsAsFactors = FALSE, max.print = 100)
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{r message = FALSE, warning=FALSE}
library(tidyr)
library(tibble)
library(magrittr)
library(dplyr)
library(stringr)
library(ggplot2)
library(gridExtra)
library(ggpubr)
library(patchwork)
library(limma)
library(edgeR)
library(SummarizedExperiment)
library(patchwork)
```

```{r}
conflicted::conflict_prefer("select","dplyr")
conflicted::conflict_prefer("filter","dplyr")
```

# Define Functions 

```{r}
#Function to create symlinks to the original data files on active to the current working directory of the R project. 
mk_symlinks <- function(linked_dirname,filepaths){
  
  if(!dir.exists(linked_dirname)){
    dir.create(linked_dirname, recursive = TRUE)
  }
  
  lapply(filepaths,function(file){
    target <- file.path(linked_dirname, basename(file))
    if(!file.exists(target)){
      command <- paste0("ln -svf '",file,"' '",target, "'")
      system(command)
    }
  })
}
```


# Sample Manifest and Expression Data

```{r}
pf_samples <- read.csv("samples/Kappe_s_2022.04_PF_LiverStage_ParasitesPaper_sample_manifest_7.25.2022.csv") %>% 
  set_rownames(.$sample_id_cat)

dim(pf_samples)
table(pf_samples$analysis_group)
```

```{r}
cb_se <- readRDS("expression_data/kappe_s_PfHsMmu_cated_Pf_ParasitesPaper_samples_Pf3D7v58_combat-seq_SummarizedExperiment.RDS")

cb_se
```

```{r}
cb_eset <- readRDS("expression_data/kappe_s_PfHsMmu_cated_Pf_ParasitesPaper_samples_Pf3D7v58_combat-seq_expressionSet.RDS")

# cb_eset
```


# Genomic References 

```{r}
txDB <- AnnotationDbi::loadDb(file="species_genomes/plasmoDB/PlasmoDB-58_Pfalciparum3D7.sqlite")
# txDB <- GenomicFeatures::makeTxDbFromGFF(file="species_genomes/plasmoDB/PlasmoDB-58_Pfalciparum3D7.gtf")
# AnnotationDbi::saveDb(txDB,file = "PlasmoDB-58_Pfalciparum3D7.sqlite")
```

```{r}
genome_fasta <- Biostrings::readDNAStringSet("species_genomes/plasmoDB/PlasmoDB-58_Pfalciparum3D7_Genome.fasta")
names(genome_fasta) <- names(genome_fasta) %>%  str_split_fixed(" | ", n=2) %>% .[,1]
```

STAR can also utilize annotations formatted as a list of splice junctions coordinates in a text file:
--sjdbFileChrStartEnd /path/to/sjdbFile.txt. 

This file should contains 4 columns separated by tabs: Chr \tab Start \tab End \tab Strand=+/-/

Here Start and End are first and last bases of the introns (1-based chromosome coordinates)

```{r}
chrom_sizes <- GRanges(seqnames = S4Vectors::Rle(names(genome_fasta)),
                       ranges = IRanges(start=1,end = width(genome_fasta)))

# chrom_sizes
# export is making the BED file 0 based??
rtracklayer::export.bed(chrom_sizes,
                    con="species_genomes/plasmoDB/PlasmoDB-58_Pfalciparum3D7_Genome.chrom_sizes.bed")
```


# Dasper 

Required Inputs:
- STAR splice junctions
- BigWig coverage files

https://bioconductor.org/packages/release/bioc/vignettes/dasper/inst/doc/dasper.html

https://www.biorxiv.org/content/10.1101/2021.03.29.437534v1.full

https://github.com/LieberInstitute/megadepth

```{r}
# BiocManager::install("dasper")
# BiocManager::install("megadepth")

library(dasper)
library(megadepth)
# options(MulticoreParam=quote(BiocParallel::MulticoreParam(4)))

# default installation path: ~/bin
# install_megadepth() # only run 1x
```

## Data Preparation 

### STAR output

```{r}
#symlink the STAR splice junctions 
star_output <- "/active/taylor_s/people/jsmi26/RSC/kappe_s_2022.04_rnaseq_quant/results/star"
indexes <- "/active/taylor_s/people/jsmi26/RSC/kappe_s_2022.04_rnaseq_quant/results/samtools"

if(length(dir("star/")) == 0 ){
 links <-  mk_symlinks(linked_dirname = here::here("star"),
                      filepaths = dir(star_output,
                                      pattern = "SJ.out.tab|.bam",
                                      full.names = TRUE))
 bai_links <- mk_symlinks(linked_dirname = here::here("star"), 
                         filepaths = dir(indexes,
                                         pattern = ".bai",
                                         full.names = TRUE))
}
```


```{r}
bams <- dir("star", 
            pattern = ".bam$", 
            full.names = TRUE) %>% 
  here::here(.)

head(bams)

dir.create("star/pf_aligned",recursive = TRUE)
outbams <- basename(bams) %>% 
  gsub(".Aligned.",".Pf_Aligned.", .) %>%  
  file.path(here::here(),"star/pf_aligned", .)

# head(outbams)
```

```{r eval=FALSE}
regions_bed <- here::here("species_genomes/plasmoDB/PlasmoDB-58_Pfalciparum3D7_Genome.chrom_sizes.bed")
save_scripts <- purrr::map2(.x = bams, .y = outbams, function(input,output){
  
  samtools_cmd <- glue::glue("samtools view -h -M -L {regions_bed} --output {output} {input}")
  
  script_name <- basename(output) %>% 
    gsub(".sortedByCoord.out.bam", ".sh", .)

  cat(samtools_cmd, 
      file=file.path("star/pf_aligned/", script_name),
      sep="\n")
  
})
```

```{bash eval=FALSE}
conda env create -f env/samtools.yml
conda activate samtools
cd star/pf_aligned/
for file in $(ls -1 *.sh)
do
  chmod +x $file 
  ./$file
done

for file in $(ls -1 *.bam)
do
  samtools index $file
done
```

```{r eval=FALSE}
sj_tabs <- dir("star", pattern = "*.tab", full.names=TRUE) %>% 
  file.path(here::here(), .)

chrom_names <- names(genome_fasta) %>% 
  paste(., collapse="|")

subset_sjs <- purrr::map(sj_tabs, function(sjs){
  outfile <- basename(sjs) %>% 
    gsub(".SJ.",".Pf_SJ.", .) %>% 
    file.path(here::here(), "star/pf_aligned", .)
  
  cmd <- glue::glue("grep -E \"{chrom_names}\" {sjs} > {outfile}")
  if(!file.exists(outfile)){
    system(cmd)
  }
  
})
```


### Convert BAM to BigWigs

```{r eval=FALSE}
dir.create("star/bigwigs", recursive = T, showWarnings = F)

save_bigwigs <- purrr::map(outbams,function(infile){
  
  in_prefix <- basename(infile) %>% 
      gsub(".bam","",.) %>% 
      paste0("star/bigwigs/", .)
  if(!file.exists(paste0(in_prefix,"all.bw")))
  megadepth::bam_to_bigwig(bam_file = infile,
                         prefix = in_prefix,
                         overwrite = FALSE)
})
```


## Dasper workflow

### All Days 2,4,5,6 

```{r}
junc_files <- data.frame(SJ.out.tab=dir("star/pf_aligned", pattern = "*.tab", full.names = T) %>% 
                           file.path(here::here(), .)) %>% 
  mutate(sample_id_cat = basename(SJ.out.tab) %>% gsub(".Pf_SJ.out.tab","", .)) 

bw_files <- data.frame(bw=dir("star/bigwigs", pattern = "*.bw", full.names = TRUE) %>% 
                         file.path(here::here(), .)) %>% 
  mutate(sample_id_cat = basename(bw) %>%  gsub(".Pf_Aligned.+", "", .))


pf_samples_dasper <- pf_samples %>% 
  left_join(., junc_files, by="sample_id_cat") %>% 
  left_join(., bw_files, by="sample_id_cat") %>% 
  mutate(controls=ifelse(analysis_group=="sporozorite", TRUE, FALSE))

# pf_samples_dasper
# write.csv(pf_samples_dasper,"splicing/Kappe_s_2022.04_PF_LiverStage_ParasitesPaper_dasper_samples.csv")
```

```{r}
juncs <- junction_load(junction_paths = pf_samples_dasper$SJ.out.tab,
                       metadata = pf_samples_dasper,
                       controls = pf_samples_dasper$controls)

# juncs
```

```{r}
juncs <- junction_annot(junctions = juncs, 
                        ref= txDB)

table(rowData(juncs)$in_ref)
#FALSE  TRUE 
# 38797  8333 
table(rowData(juncs)$type)
```

```{r}
juncs <- junction_filter(juncs, 
                         count_thresh = c(raw = 5),
                         n_samp = c(raw = 3))

table(rowData(juncs)$in_ref)
#FALSE  TRUE 
# 1185  6399 
# table(rowData(juncs)$type)
```

For normalization:

cluster each junction by finding all other junctions that share an acceptor or donor site with it. 

Then, calculate the normalized counts by dividing the number of reads supporting each junction with the total number of reads in it’s associated cluster.

For scoring:

score each patient junction by how much it’s (normalized) counts deviate from the count distribution of the same junction in the control samples using junction_score.

---> 
Within introns, a donor site (5' end of the intron), a branch site (near the 3' end of the intron) and an acceptor site (3' end of the intron) are required for splicing.

The splice donor site includes an almost invariant sequence GU at the 5' end of the intron, within a larger, less highly conserved region. 

The splice acceptor site at the 3' end of the intron terminates the intron with an almost invariant AG sequence
<----

```{r}
#normalize our raw junctions counts into a proportion-spliced-in 
juncs <- junction_norm(juncs)
junctions_norm <- juncs

# Score the junctions compared to controls
# scoreing the junctions changes the norm counts?? so save the normalized object alone
juncs <- junction_score(juncs)
```

```{r}
SummarizedExperiment::assays(juncs)

head(SummarizedExperiment::assays(juncs)[["norm"]])
head(SummarizedExperiment::assays(junctions_norm)[["norm"]])

# quantile(SummarizedExperiment::assays(juncs)[["raw"]])

# hist(SummarizedExperiment::assays(juncs)[["norm"]])
# hist(SummarizedExperiment::assays(junctions_norm)[["norm"]])

# quantile(SummarizedExperiment::assays(juncs)[["score"]])
```

Coverage Normalization:

 normalizing the coverage across regions associated with each junction.
 
 There are the 2 exonic regions flanking each junction and the intron inbetween == there are 3 regions for each junction. 
 
coverage_score:

  used to compare the coverage associated with each junction to the coverage distribution corresponding to the same region in controls.

> For potentially faster BigWig reading performance, please sort your argument to --annotations (BED) file via sort -k1,1 -k2,2n and re-run megadepth.

```{r}
bw_case <- pf_samples_dasper$bw[!pf_samples_dasper$controls]
bw_control <- pf_samples_dasper$bw[pf_samples_dasper$controls]

coverage <- coverage_norm(junctions = juncs,
                          ref = txDB,
                          coverage_paths_case = bw_case,
                          coverage_paths_control = bw_control,
                          bp_param = BiocParallel::MulticoreParam(4))
```

```{r}
juncs <- coverage_score(junctions = juncs,
                        coverage = coverage)

names(SummarizedExperiment::assays(juncs))
```

```{r}
juncs <- outlier_detect(
    junctions = juncs,
    bp_param = BiocParallel::SerialParam(),
    # bp_param = BiocParallel::MulticoreParam(4),
    random_state = 32L
)
```

 outlier_scores object contains a DataFrame with each row detailing a cluster in terms of how aberrant it looks. 

The gene_id_cluster column describes the gene linked to each cluster, derived from the gene annotations.

Splicing events are ranked in the rank column with 1 referring to the most aberrant splicing event in that patient.

```{r}
outlier_scores <- outlier_aggregate(junctions = juncs, 
                                    samp_id_col = "sample_id_cat")

# outlier_scores %>%  
#   as.data.frame() %>% 
#   head()
dim(outlier_scores)
unique(outlier_scores$samp_id) %>%  length()
```

```{r}
assays(juncs)
outlier_scores[1,"junctions"]
# outlier_scores[1,"gene_id_cluster"]
assay(juncs,"raw") %>% head() # doesn't have any rownames or identifiers to help extract the raw counts ...
juncs@rowRanges[juncs@rowRanges$index %in% c(4689,4726)]
# view(pf_samples_dasper)
```

```{r}
outscores_clean <- outlier_scores %>% 
  as.data.frame() %>% 
  left_join(., pf_samples_dasper, by=c("samp_id"="sample_id_cat")) %>% 
  mutate(has_gene_id=sapply(gene_id_cluster, function(x) length(x) > 0)) %>% 
  select(samp_id, analysis_group_id, analysis_group,has_gene_id, everything())

outscores_clean
# length(unique(outscores_clean$analysis_group_id))
```

```{r}
temp <- outscores_clean %>% 
  group_by(samp_id) %>% 
  filter(has_gene_id) %>% 
  dplyr::slice(1) %>% 
  ungroup()

temp
```

```{r}
mcols(junctions_norm)
```

```{r}
id <- unlist(temp[["gene_id_cluster"]][1])
dasper::plot_sashimi(junctions = junctions_norm, 
             ref = txDB, 
             gene_tx_id = id,
             gene_tx_col = "gene_id")
```

```{r}
junctions_example
```

### Pairwise Day vs SPZ

```{r}
junc_files <- data.frame(SJ.out.tab=dir("star/pf_aligned", pattern = "*.tab", full.names = T) %>% 
                           file.path(here::here(), .)) %>% 
  mutate(sample_id_cat = basename(SJ.out.tab) %>% gsub(".Pf_SJ.out.tab","", .)) 

bw_files <- data.frame(bw=dir("star/bigwigs", pattern = "*.bw", full.names = TRUE) %>% 
                         file.path(here::here(), .)) %>% 
  mutate(sample_id_cat = basename(bw) %>%  gsub(".Pf_Aligned.+", "", .))


pf_samples_dasper <- pf_samples %>% 
  left_join(., junc_files, by="sample_id_cat") %>% 
  left_join(., bw_files, by="sample_id_cat") %>% 
  mutate(controls=ifelse(analysis_group=="sporozorite", TRUE, FALSE))

# pf_samples_dasper
# write.csv(pf_samples_dasper,"splicing/Kappe_s_2022.04_PF_LiverStage_ParasitesPaper_dasper_samples.csv")
```

# Session Info

```{r}
sessionInfo()
```

